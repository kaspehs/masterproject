method: hnn

data:
  file: data.npz
  steadystate: false
  steadystate_time_threshold: 10.0
  reduce_time: true
  reduction_factor: 100
  middle_time_plot: [15, 17]
  use_generated_train_series: false
  train_series_dir: Data_Gen/generated_series

model:
  rho: 1000.0
  D: 0.1
  structural_mass: 16.79
  Ca: 1.0
  k: 1218.0
  U: 0.65
  damping_c: 1e-4
  max_damping_ratio: 0.2
  include_physical_drag: false
  learn_hamiltonian: false
  discover_damping: false
  use_pirate_force: false
  pirate_force_kwargs: {}
  use_fourier_features: false
  fourier_features: 64
  fourier_sigma: 1.0
  use_feature_engineering: false

smoothing:
  use_savgol_smoothing: true
  window_length: 15
  polyorder: 4

architecture:
  force_net_type: residual
  residual_kwargs:
    hidden: 128
    layers: 2
    activation: gelu
  mlp_kwargs:
    hidden: 100
    layers: 2
    activation: gelu
  pirate_force_kwargs:
    fourier_features: 96
    sigma: 0.5
    use_rwf: true
    activation: tanh

training:
  batch_size: 32
  max_grad_norm: 10000.0
  epochs: 2000

optim:
  lr: 0.001
  optimizer: adam
  weight_decay: 1e-5
  use_lr_scheduler: true
  scheduler:
    max_lr: 0.001
    decay_rate: 0.99
    warmup_steps: 200
    decay_steps: 200
    min_lr: 0.0001
    scheduler_type: exponential

loss:
  force_reg: 0.01
  # Optional supervised loss on measured force (requires force to be present in the .npz files).
  # Uses midpoint state z_mid = 0.5*(z_i+z_{i+1}) and midpoint force f_mid = 0.5*(f_i+f_{i+1}).
  use_force_data_loss: false
  force_data_weight: 1.0
  use_gradnorm: true
  gradnorm_alpha: 0.9
  gradnorm_min_weight: 0.2
  gradnorm_max_weight: 5.0

runtime:
  device: auto
  num_workers: 0

precision:
  use_tf32: false
  use_amp: false
  amp_dtype: bf16

compile:
  use_compile: false
  compile_mode: default

monitoring:
  rollout_every_epochs: 50
  validate_every_epochs: 10
  rollout_max_trajectories: 1
  log_every_epochs: 1
  print_every_epochs: 1
  log_component_grad_norms: false

hnn:
  # How to obtain velocity used to build the state (y, p=m*v) for training/validation.
  # - compute: compute v from y using finite-diff / optional Savitzky-Golay smoothing
  # - file: read v from the dataset (.npz must contain e/dy/v)
  # - auto: use file v if present, otherwise compute
  velocity_source: compute
pinn: {}

logging:
  run_dir_root: HNNruns
